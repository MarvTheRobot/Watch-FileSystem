Properties {
    $Environment   = $BuildEnvironment    
    $projectProps  = Import-PowerShellDataFile -Path (
                        Join-Path $Environment.ProjectPath 'project.properties.psd1'
                    )
     
    $moduleName  = $projectProps.Name
    $projectRoot = $Environment.ProjectPath
    $sourceRoot  = $Environment.ModulePath
    $outputRoot  = $Environment.BuildOutput
    $outputPath  = Join-Path $outputRoot $moduleName

    $manifestSourcePath = $Environment.PSModuleManifest
    
    $testRoot       = Join-Path $projectRoot 'test'
    $libRoot        = Join-Path $projectRoot 'lib'
    $testResults    = Join-Path $projectRoot 'TestResults'

    if($projectProps.OutputVersioning -eq $true){
        $outputPath = Join-Path $outputRoot (Join-Path $moduleName $projectProps.Version)
    }

    $moduleFileOutputPath = Join-Path $outputPath "$moduleName.psm1"

    $codeFolders    = "classes", "private", "public" #contents will be copied into PSM1 module file
    $copyFolders    = @() #folders within /src that need to be copied 'as-is' into module output
    $requirements   = Join-Path $projectRoot 'requirements.psd1'
}

FormatTaskName (("-" * 24) + ">[{0}]<" + ("-" * 24))

function Remove {
    [cmdletbinding()]
    param(
        [string]$Path,
        [string]$Description
    )
    "Removing $description"
    $item = Get-Item -Path $Path -ErrorAction SilentlyContinue
    if($null -ne $item){
        $item | Remove-Item -Recurse -Force -Confirm:$false | Out-Null
        if(-not(Test-Path $item.FullName)){
            "...$($item.BaseName) removed"
        }else{
            throw "UNABLE TO REMOVE $Path"
        }
    }else{
        "...already clean. Nothing to do"
    }
}

Task Default -Depends Clean, Build, Test, Analyze

Task Build -Depends Clean, CompileModule, CreateManifest {}

Task CompileModule {
    Set-BuildEnvironment -Path $projectRoot -Force
    #Create a new output folder, based on output path
    if (-not(Test-Path $outputPath)) {
        New-Item -ItemType Directory -Path $outputPath | Out-Null
    }

    #If there is a <modulename>.psm1 in src root, use it as preferred over generated
    #otherwise build one
    $authorModuleFile = Join-Path -Path $sourceRoot -ChildPath $moduleName -Resolve -ErrorAction SilentlyContinue
    if($null -ne $authorModuleFile){
        Write-Verbose "Author module file found, will copy"
        $authorModuleFile | Copy-Item -Destination $moduleFileOutputPath -Force -ErrorAction Stop
    }else{
        Write-Verbose "No author module file found, will copy"
        #Write the content from each function file into the module file
        "# Generated by Psake 'Build' Task @ $(Get-Date)`n"   |
            Out-File -Path $moduleFileOutputPath -Force -Encoding utf8
        "# -------------------------------------------------" | 
            Out-File -Path $moduleFileOutputPath -Append -Encoding utf8
        
        #Loop through all source folders in $codeFolders,
        #  Copy content into single <module>.psm1 file
        foreach ($sourceFolder in $codeFolders) {
            Write-Verbose "Compiling $sourceFolder artefacts"
            if('public', 'private' -contains $sourceFolder){
                $sourceFolderLabel = "$sourceFolder functions"
            }else{
                $sourceFolderLabel = $sourceFolder
            }

            "`n#region $sourceFolderLabel" | 
                Out-File -Path $moduleFileOutputPath -Append -Encoding utf8

            $lookInPath = Join-Path -Path $sourceRoot -ChildPath $sourceFolder -Resolve -ErrorAction SilentlyContinue
            if($null -ne $lookInPath){
                $scriptFiles = Get-ChildItem -Path $lookInPath -Include "*.ps1" -Exclude "*.tests.ps1" -Recurse

                if($scriptFiles -is [System.IO.FileSystemInfo] -or $scriptFiles -is [System.Array]){
                    Get-Content $scriptFiles | 
                    Out-File -Path $moduleFileOutputPath -Append -Encoding utf8
                }else{
                    "# `tNo $sourceFolderLabel in module" | 
                    Out-File -Path $moduleFileOutputPath -Append -Encoding utf8
                }
            }

            "#endregion $sourceFolderLabel" | 
            Out-File -Path $moduleFileOutputPath -Append -Encoding utf8

            "# ===============================================`n" | 
            Out-File -Path $moduleFileOutputPath -Append -Encoding utf8
        }

        #If there are public functions ensure they are exported at the bottom of the .PSM1 file.
        $publicFunctions = Get-ChildItem -Path (
                                            Join-Path $sourceRoot 'public'
                                          ) -Include "*.ps1" -Exclude "*.tests.ps1" -Recurse

        if ($null -ne $publicFunctions -and $publicFunctions.Count -gt 0) {
            $quotedFunctions = $publicFunctions | foreach-object {"'$($_.BaseName)'"}

            "Export-ModuleMember -Function @($($quotedFunctions -Join ', '))`n" | 
                Out-File -Path $moduleFileOutputPath -Append -Encoding utf8
        }

        #If the src directory contains a <modulename>.partial.psm1 file, append it's contents to this module file
        #I'm using .partial. for now so that we are sure it's the intention of the module author
        $partialName = "$moduleName.partial.psm1"
        $partialModuleFile = Join-Path -Path $sourceRoot -ChildPath $partialName -Resolve -ErrorAction SilentlyContinue
        if($null -ne $partialModuleFile){
            "# Import $partialName -----------------------`n" | 
            Out-File -Path $moduleFileOutputPath -Append -Encoding utf8

            $partialContent = Get-Content -Path $partialModuleFile -Raw -Encoding utf8
            $partialContent | Out-File -Path $moduleFileOutputPath -Append -Encoding utf8
        }
        "# ===============================================" | 
        Out-File -Path $moduleFileOutputPath -Append -Encoding utf8
    }    
}

Task CreateManifest {
    $moduleProperties = @{
        GUID          = $projectProps.GUID
        RootModule    = $projectProps.Name
        ModuleVersion = $projectProps.Version
        Description   = $projectProps.Description
        Author        = $projectProps.Author
        CompanyName   = $projectProps.CompanyName
        Copyright     = $projectProps.Copyright
        #Prerelease    = $projectProps.PreRelease
        FunctionsToExport = $publicFunctions
        Path          = Join-Path -Path $outputPath -ChildPath "$($moduleName).psd1"
    }

    if($projectProps.AliasesToExport -is [string] -or $projectProps.AliasesToExport -is [string[]]){
        $moduleProperties += @{AliasesToExport = $projectProps.AliasesToExport}
    }

    New-ModuleManifest @moduleProperties -ErrorAction Stop
    (Get-ChildItem $outputPath).FullName    
}

Task CleanAll -Depends CleanModules, CleanTestResults {
    Remove $outputRoot "all previous builds of module"
}

Task CleanTestResults {
    Remove $testResults "previously executed test results"
}

Task CleanModules {
    Remove $libRoot "modules downloaded into the project folder"
}

Task Clean {
    Remove $outputPath "previous build of same module version"
}

task Test {
    if(-not(Test-Path -Path $testResults)){
        New-Item -Path $testResults -ItemType Directory
    }
    
    $resultsFilePath = Join-Path -Path $testResults -ChildPath "$moduleName-UNIT-RESULTS.xml"
    $results = Invoke-Pester -Path $sourceRoot -OutputFile $resultsFilePath -OutputFormat NUnitXml -PassThru
    
    if ($results.FailedCount -gt 0) {
        $results | Format-List
        Write-Error -Message 'One or more Pester tests failed. Build cannot continue!'
    }
}

task Analyze {
    if(-not(Test-Path -Path $testResults)){
        New-Item -Path $testResults -ItemType Directory
    }

    Get-ChildItem -Path $testRoot -File | foreach-object {
        $resultsFilePath = Join-Path -Path $testResults -ChildPath "$($_.BaseName)-STYLE-RESULTS.xml"
        $results = Invoke-Pester -Path $_.FullName -OutputFile $resultsFilePath -OutputFormat NUnitXml -PassThru
            
        if ($results.FailedCount -gt 0) {
            $results | Format-List
            Write-Error -Message 'One or more Pester tests failed. Build cannot continue!'
        }   
    }
}

Task BuildDocs {

}
